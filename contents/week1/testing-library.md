---
description: Jest와 React Testing Library
---

# Testing Library

> 내가 과거에 했던 프로젝트에서는 테스트없이 기능을 개발했다. 처음 한두가지에서는 문제가 없었지만 기능이 복잡하거나 여러 유닛이 겹쳐질 때 생기는 문제에 대해서 미리 대비하지 못하고 그때그때 처리할 수 밖에 없었다. 그러다보면 코드가 지저분해지고, 다시 되돌릴 수도 없었으며 앞으로 유지보수 할 생각에 눈 앞이 깜깜했다. 다시는 이런 일이 없었으면 하는 마음으로 테스팅에 대해 배워보려고 한다.

과거에는 웹이 복잡하지 않아 테스트가 필요하지 않았지만, 점차 프론트엔드가 복잡해지고 다양한 프레임워크와 라이브러리가 생겨나면서 프론트엔드 관리와 코드 퀄리티의 중요성이 대두되고 있다. 테스트로 인해 원하는 시나리오대로 동작이 잘 되는지 확인할 수 있고, 디버깅이 쉬워져 차후 유지보수 하거나 코드를 수정할 때도 안정적으로 진행할 수 있다.



## 테스트 종류

#### 유닛 테스트&#x20;

프로젝트의 가장 작은 단위를 테스트한다. 단일 컴포넌트, 단일 서비스가 될 수 있다.&#x20;

단, 기능이 자주 바뀔 가능성이 있는 프로젝트에는 부적합하다.

#### 통합 테스트

통합된 기능을 테스트한다. 전체 유닛의 상호작용에 대해서 테스트가 가능하다.

#### E2E 테스트

E2E(End to End) 테스트는 사용자로부터 백엔드 인프라까지 테스트한다.&#x20;

사용자 관점에서 전체 시나리오를 테스트하기 때문에 중간에 코드가 변경되더라도 테스트를 변경할 필요가 없다.

다만, 전체를 테스트하기 위해선 굉장히 많은 테스트가 필요하다.



## given-when-then

테스트 시나리오를 작성할때는 주로 Given-When-Then을 패턴을 이용하여 테스트를 진행한다.

* given : 주어진 조건을 명시한다. 테스트할 데이터나 컴포넌트를 초기화 하는 로직이 들어갈 수 있다.
* when : 테스트할 행동에 대한 코드를 작성한다.
* then : 테스트 행동에 대한 검증을 실시한다. 단, 어떠한 로직(행동)도 담아선 안된다.

```javascript
// given
const num1 = 1;
const num2 = 2;

// when
const result = plus(num1, num2);

// then
assert result === 3;
```



## Jest

Jest는 자바스크립트 테스팅 라이브러리이다.&#x20;

Jest 이전에 자바스크립트에서 테스트를 하려면 Test Runner, Test Matcher, Test Mock 라이브러리 등 다양한 테스팅 라이브러리가 필요했다. 하지만 Jest는 이 모든걸 제공해주어 반응이 뜨거웠고, '테스팅 프레임워크' 라는 별칭도 붙었다.

### Jest 특징

1. 별도의 설정 없이 바로 사용할 수 있다.
2.  스냅샷 기능 제공

    \-> 어떤 기능에 대한 구현을 바꾼 후에 테스트에 실패하면, `-u` 옵션으로 테스트 자체를 업데이트 시킬 수 있다.
3. 테스트 코드는 모두 분리되어 있다. 테스트가 동시에 진행되어 전체 테스트 시간을 줄여준다.

### Jest 기본 문법

```javascript
test("테스트 설명", () => {
  expect("검증 대상").toXX("기대 결과");
});

test("두 숫자의 합을 반환한다", () => {
  expect(add(1, 2)).toXX(3);
});
```



## React Testing Library&#x20;

React를 테스트할 수 있는 도구이다. CRA 시 자동으로 설치된다. 실제 브라우저에서 보여지는 DOM을 기준으로 테스트를 작성하게 된다.

### React Testing Library 사용법

* render : ( ) 안의 요소가 렌더링 되었는지 확인
* screen : render와 비슷하게 렌더링 된 요소를 기준으로 테스팅 할 때 사용할 수 있다. 단, screen을 사용하기 위해서는 **먼저 render 함수를 통해서 컴포넌트를 호출해야 한다.**

```javascript
test("테스트 설명", () => {
  render(<컴포넌트 />);
  screen.getByText('문자열1'); // 문자열1이 존재하는지
  screen.getByText(/문자열2/); // 문자열2가 결과물에 포함 되었는지
  expect(screen.queryByText(/문자열3/).toBeFalsy(); // 문자열3이 존재하는가에 대한 결과가 falsy 인지
  expect(screen.queryByText(/문자열4/).not.toBeInTheDocument(); // 문자열4을 찾아봤는데 없는지
});
```

위 코드는 이런 방법으로도 사용할 수 있다는 예시를 보여주고 있다.



## expect 뒤의 .toXx

index.d.ts 파일에서 다른 Matcher 함수 종류가 명시되어 있다. vscode 내에서 `.toXx` 부분을 `Command + Click` 하면 바로 볼 수 있다.

{% hint style="info" %}
_유용한 Matcher 함수_ 검색 시 다양한 Matcher 함수를 확인할 수 있다. 참고하자.
{% endhint %}

_<mark style="background-color:yellow;"></mark>_

## BDD 스타일로 테스트하기

BDD는 Behavior Driven Development의 약자로, 테스트를 시나리오 기반으로 작성하는 것을 말한다. 아래의 예시처럼 하나의 describe 안에서 여러 개의 context, it 을 사용하여 테스트 할 수 있다.

* describe : 테스트의 대상을 명시, 유닛 테스트 모음
* context : 테스트 대상이 놓인 상황을 설명(추가 조건)
* it(test) : 테스트 대상의 행동을 설명

```javascript
const context = describe;
describe('add 함수에 대해', () => {
  it("두 숫자의 합을 돌려준다", () => {
    expect("검증 대상").toXX("기대 결과");
  });
    
  context('두 숫자가 다 음수라면', () => {
    it("0을 리턴한다", () => {
      expect("검증 대상").toXX("기대 결과");
    });
  });
  
  context('양수, 음수가 각각 하나씩 주어지면', () => {
    it("항상 더 작은 값을 돌려준다", () => {
      expect("검증 대상").toXX("기대 결과");
    });
  })
});
```
