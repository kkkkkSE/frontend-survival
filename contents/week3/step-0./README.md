---
description: '키워드 : API, 선언형 프로그래밍'
---

# Step 0. 준비하기

UI 설계 계획을 세우기 위해 준비해야 할 것이 두 가지 있다. 첫 번째는 UI에 반영할 **데이터**, 두 번째는 **UI 디자인**이다. _(완성된 디자인일 필요는 없고, 러프하게 잡은 목업이어도 관계 없다.)_

데이터를 어떤 모양으로 받아 어떻게 사용하고, 어떤 방식으로 화면 요소를 구성할건지 등을 분석해보고 설계를 시작해야 한다.

이 페이지에서는 이후 단계에서 알고 있으면 좋을 개념을 몇 가지 소개하고자 한다.



## API

웹에서는 클라이언트가 데이터를 달라고 하거나, 생성, 수정, 삭제해달라고 **요청**하면, 서버에서 요청을 받아들이거나 클라이언트 문제 또는 서버의 문제 등으로 요청을 받아들일 수 없다고 **응답**하는 대화가 이루어진다.

이처럼 **API(Application Programming Interface)** 는 클라이언트와 서버, 또는 두 시스템 간에 서로 대화할 수 있도록 만든 규약이다.

우리는 이 API를 이용하여 유저가 브라우저에서 쉽게 서버에 요청할 수 있도록 UI에 반영하여 설계하게 된다.

###

### REST API

[REST API 노트 바로가기](./#rest-api)

###

### GraphQL

[GraphQL 노트 바로가기](./#graphql)

###

### REST API vs GraphQL

#### **REST API 장단점**

* HTTP Method와 URI를 조합해서 예측 가능하고 일정한 정보와 작업을 요청한다.
* 받아와야 하는 항목이 많고 정해져있을 경우 GraphQL보다 유리할 수 있다.(요청의 단순함)
* 파일 전송처럼 단순 텍스트로 처리되지 않는 요청이 있을 때 사용하기 좋다.
* 필요한 정보를 위해 요청했지만 필요하지 않은 정보도 함께 받아지는 경우가 있다. 전송되는 데이터의 양이 많아진다.
* 필요한 정보를 여러 Resource에서 받아와야 한다면 요청 횟수가 많아진다.

#### **GraphQL 장단점**

* 원하는 정보만 구체적으로 골라서 데이터를 받아올 수 있다. 여러 Depth의 데이터를 얻는 것도 가능하다.
* 한 번의 요청으로 많은 데이터를 받아올 수 있다.
* 상황에 따라 응답의 사이즈를 줄일 수 있다.
* 대부분의 요청이 CRUD일 때 사용하기 좋다.
* 데이터의 요청이 복잡하다.
* 고정된 요청과 응답만 필요한 경우 Query로 인해 요청의 크기가 더 클 수 있다.

#### **결론**

GraphQL을 사용하는 건 역할의 분리라고 할 수 있다. 클라이언트와 서버 사이에 GraphQL이 있고, 클라이언트에서 요청을 받으면 GraphQL에서 절차적으로 데이터를 처리하여 요청한대로 응답을 보내준다.

웹의 규모가 클 때 모듈을 만들어 역할을 분리하면 각 모듈의 유지보수는 쉬워지지만, 구현할 때는 더 복잡한 것처럼 GraphQL도 마찬가지다. GraphQL을 사용함으로써 클라이언트는 이를 편하게 이용할 수 있지만, 원래 우리가 하던 데이터의 조합 역할을 넘기는 것과 같아 서버에서는 일이 더 가중될 수 있다.

따라서 웹의 규모, 사이즈에 따라 어떤 방식을 도입할 지 고려해야 한다.

###

### JSON

JSON(JavaScript Object Notation)은 텍스트 기반의 데이터 포맷으로, 데이터를 기술하고 교환하는 가장 보편적인 매체로 사용되는 형식이다.

#### **특징**

* 간결하다.
* 자바스크립트 객체 표기법을 따른다.
* 사람과 기계 모두 읽기 간편한 형태이다.
* 프로그래밍 언어와 운영체제에 독립적이어서 데이터 교환에 유용하다.
* 유연성이 뛰어나 자유자재로 CRUD가 가능하다.

위처럼 다른 데이터 포맷에 비해 장점이 많아 보편적으로 사용된다.

#### **형태**

```json
{
  "userId" : "hong",
  "product" : [
    {
      "name" : "a",
      "price" : 1000,
      "stock" : true
    },
    {
      "name" : "b",
      "price" : 2000,
      "stock" : false
    }
  ]
}
```

특징에서도 말했듯, Key-Value로 데이터를 나타내는 자바스크립트의 객체 형태와 같으며, 기본 데이터 타입인 문자, 숫자, 배열, boolean, 객체, null을 포함할 수 있다.

자바스크립트의 객체와 동일하게 점 표기법이나 브라켓 표기법으로 데이터에 접근할 수 있다.

```js
product.userId // 'hong'
product["userId"] // 'hong'
```

#### **메서드**

자바스크립트에는 JSON과 관련된 메서드가 2개 있다.

* `JSON.stringify()` : 자바스크립트의 객체 리터럴을 문자열(텍스트 형식)으로 바꿔준다. 서버로 데이터 형식을 보낼 때 필요하다.
* `JSON.parse()` : 는 서버에서 받은 데이터를 자바스크립트의 객체 리터럴로 바꿀 때 사용한다. 객체 리터럴로 변경하면 일반 자바스크립트 객체처럼 자유롭게 사용할 수 있다.

참고로, fetch API를 이용해서 데이터를 받아올 경우 `.json()` 메서드를 `JSON.parse()`와 동일하게 사용할 수 있다.

```js
fetch('http://example.com/movies.json')
  .then((response) => response.json())
  .then((data) => console.log(data));
```

이 코드를 실행하면 서버에서 받아온 data가 console에 기록된다.

## 프로그래밍 패러다임

프로그래밍 패러다임이란, '프로그래밍을 어떤 관점으로 보고, 어떤 방식으로 접근하는가에 대한 이론적인 틀' 정도로 해석할 수 있다. 프로그래밍 패러다임에 따라 지향하는 프로그래밍 원칙이 달라진다.

이 프로그래밍 패러다임은 크게 **선언형 프로그래밍**과 **명령형 프로그래밍**으로 나누어진다. 갑자기 이 얘기를 왜 하고있냐면, **React의 큰 특징 중 하나**가 이 **선언형** 방식을 따르고 있기 때문이다.

### 명령형 vs 선언형

명령형 프로그래밍은 **어떻게(How)** 할 것인지에 대한 **절차에 초점**을 둔다.&#x20;

선언형 프로그래밍은 **어떤 것을(What)** 할 것인지에 초점을 둔다. **절차는 중요하지 않다.**



아래는 배열에서 짝수의 개수를 세는 예제이다.

```js
const nums = [1, 2, 3, 4, 5];
let count;

count = 0;

for (let i = 0; i < nums.length; i++) {
  if (i % 2 === 0) {
    count++;
  }
}

console.log(count); // 2
```

이와 같이 명령형 코드는 for문을 통한 배열의 순회, 각 요소가 짝수인지 조건문으로 체크, 카운트 하는 것 모두 직접적으로 코드에서 과정을 확인할 수 있다.

```js
const nums = [1, 2, 3, 4, 5];
let count;

count = nums.filter(el => !(el % 2)).length;

console.log(count); // 2
```

이와 같이 선언형 코드는 명령형 코드처럼 친절하게 절차를 알려주지는 않는다. 다만, 작업을 지시했고, 원하는 결과가 나오는지에만 포커스가 맞춰져있다. 절차는 추상화되어 _'명령형 코드처럼 잘 만들어져 있겠지\~'_ 하는 것이다.

### React의 선언형 View

React에서 UI를 구현할 때 또한 작업 지시와 결과에 초점이 맞춰져있다. React의 장점으로 선언형이 꼽히는 이유는 다음과 같다.

```js
const root = document.getElementById('root'); 
const title = document.createElement('h1'); 
title.innerText = 'Hello World!';

root.appendChild(header); 
```

```js
const title = <h1>Hello World!</h1>;
ReactDOM.render(title, document.getElementById('root'));
```

위 두 코드는 같은 결과를 나타낸다. 윗 코드처럼 DSL\*인 JSX를 사용하지 않고, 라이브러리를 사용하는 대신 직접 화면을 구성했을 때 번거롭고, 양이 많으면 많을수록 예측이 어렵고 수정이 복잡하다.

하지만 아래처럼 JSX를 사용하고, ReactDOM의 render 함수를 사용했을 때 어떤 결과를 나타내고자 하는지를 알아채기 쉽고, 코드도 간결하다. 그 안에서 어떤 과정을 통해 화면에 뿌려주는 지는 잘 추상화되어 있다. 화면을 수정할 때도 훨씬 간편하다.

{% hint style="info" %}
**DSL(Domain-Specific Languages)** : 특정 분야에 최적화된 프로그래밍 언어를 말한다. JSX는 특정 환경, 특히 React에서만 사용할 수 있는 것은 아니지만, React를 다루기 쉽게 만드는 데 큰 비중을 차지한다. JSX에 대한 내용은 JSX 페이지를 참고하자.
{% endhint %}
